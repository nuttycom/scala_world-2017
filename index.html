<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Kris Nuttycombe (@nuttycom)" />
  <title>Describing Data</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="./slidy/styles/slidy.css" />
  <script src="./slidy/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Describing Data</h1>
  <p class="author">
Kris Nuttycombe (<span class="citation">@nuttycom</span>)
  </p>
  <p class="date">September, 2017</p>
</div>
<div id="goals" class="slide section level2">
<h2>Goals</h2>
<ul>
<li>Explore the design of an FP library from start to finish</li>
<li>Introduce <strong>free applicative functors</strong> in the context of a &quot;real-world&quot; problem</li>
<li>Discuss how <strong>fix-point types</strong> allow us to annotate recursive data structures</li>
<li>Touch on how <strong>recursion schemes</strong> can save library users some potential errors</li>
<li>See how these things come together in the <a href="https://github.com/nuttycom/xenomorph"><strong>xenomorph</strong></a> library</li>
<li>Discover how what we write at kind <code>* -&gt; *</code> is related to what we write at kind <code>*</code></li>
</ul>
</div>
<div id="prerequisites" class="slide section level2">
<h2>Prerequisites</h2>
<ul>
<li>Sum types / GADTs</li>
<li>Product types</li>
<li>Applicative functors</li>
<li>Higher-kinded types / type constructors</li>
<li>Type-level lambdas / kind-projector</li>
<li>Natural transformations</li>
<li>Coproducts</li>
</ul>
</div>
<div id="overview" class="slide section level2">
<h2>Overview</h2>
<div id="problem-serialization" class="section level3">
<h3>Problem: Serialization</h3>
<ul>
<li>Having to maintain both serializers and deserializers is silly.</li>
<li>Problems exist with macros/generic programming approaches.</li>
<li>Legacy wire formats &amp; evolving protocols can present challenges.</li>
</ul>
<div class="incremental">
<h3 id="solution">Solution:</h3>
<ul>
<li>Build a description of the data structure as a value.</li>
<li>Build interpreters for that description that produce serializers, deserializers, and more.</li>
</ul>
</div>

</div>
</div>
<div id="example" class="slide section level2">
<h2>Example</h2>
<p>A simple sums-of-products data type.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">Person</span>(
  name: String, 
  birthDate: Instant,
  roles: Vector[Role]
)

<span class="kw">sealed</span> <span class="kw">trait</span> Role

<span class="kw">case</span> <span class="kw">object</span> User <span class="kw">extends</span> Role
<span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Administrator</span>(department: String) <span class="kw">extends</span> Role</code></pre></div>
<div class="incremental">
<ul>
<li>Primitives</li>
</ul>
</div>
<div class="incremental">
<ul>
<li>Sequences</li>
</ul>
</div>
<div class="incremental">
<ul>
<li>Records</li>
</ul>
</div>
<div class="incremental">
<ul>
<li>Sum types</li>
</ul>
</div>
</div>
<div id="example-json-representation" class="slide section level2">
<h2>Example JSON Representation</h2>
<div class="sourceCode"><pre class="sourceCode json"><code class="sourceCode json"><span class="fu">{</span>
  <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;Kris Nuttycombe&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;birthDate&quot;</span><span class="fu">:</span> <span class="dv">201470280000</span><span class="fu">,</span>
  <span class="dt">&quot;roles&quot;</span><span class="fu">:</span> <span class="ot">[</span>
    <span class="fu">{</span>
      <span class="dt">&quot;admin&quot;</span><span class="fu">:</span> <span class="fu">{</span> <span class="dt">&quot;department&quot;</span><span class="fu">:</span> <span class="st">&quot;windmill-tilting&quot;</span> <span class="fu">}</span>
    <span class="fu">}</span> 
  <span class="ot">]</span>
<span class="fu">}</span>

<span class="fu">{</span>
  <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;Jon Pretty&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;birthDate&quot;</span><span class="fu">:</span> <span class="dv">411436800000</span><span class="fu">,</span>
  <span class="dt">&quot;roles&quot;</span><span class="fu">:</span> <span class="ot">[</span>
    <span class="fu">{</span>
      <span class="dt">&quot;user&quot;</span><span class="fu">:</span> <span class="fu">{}</span>
    <span class="fu">}</span>
  <span class="ot">]</span>
<span class="fu">}</span></code></pre></div>
</div>
<div id="example-schema" class="slide section level2">
<h2>Example Schema</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> personSchema: Schema[Prim, Person] = <span class="fu">rec</span>(
  ^^(
    <span class="fu">required</span>(<span class="st">&quot;name&quot;</span>, Prim.<span class="fu">str</span>, Person.<span class="fu">name</span>.<span class="fu">asGetter</span>),
    profTProp.<span class="fu">dimap</span>(<span class="fu">required</span>(<span class="st">&quot;birthDate&quot;</span>, Prim.<span class="fu">long</span>, identity)) {
      (_: Person).<span class="fu">birthDate</span>.<span class="fu">getMillis</span>
    } {
      <span class="kw">new</span> <span class="fu">Instant</span>(_: Long)
    },
    <span class="fu">required</span>(<span class="st">&quot;roles&quot;</span>, Prim.<span class="fu">arr</span>(roleSchema), (_: Person).<span class="fu">roles</span>)
  )(Person.<span class="fu">apply</span> _)
)</code></pre></div>
<p>To avoid type ascriptions, use all of <span class="citation">@tpolecat</span>'s flags from <a href="">here</a></p>
</div>
<div id="example-schema-1" class="slide section level2">
<h2>Example Schema</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> roleSchema: Schema[Prim, Role] = Schema.<span class="fu">oneOf</span>(
  alt[Unit, Prim, Role, Unit](
    <span class="st">&quot;user&quot;</span>, 
    Schema.<span class="fu">empty</span>,
    Role.<span class="fu">user</span> composeIso GenIso.<span class="fu">unit</span>[User.<span class="fu">type</span>]
  ) ::
  alt[Unit, Prim, Role, Administrator](
    <span class="st">&quot;administrator&quot;</span>, 
    <span class="fu">rec</span>(
      ^(
        <span class="fu">required</span>(<span class="st">&quot;department&quot;</span>, Prim.<span class="fu">str</span>, (_: Administrator).<span class="fu">department</span>),
        <span class="fu">required</span>(<span class="st">&quot;subordinateCount&quot;</span>, Prim.<span class="fu">int</span>, (_: Administrator).<span class="fu">subordinateCount</span>)
      )(Administrator.<span class="fu">apply</span> _)
    ),
    Role.<span class="fu">admin</span>
  ) :: Nil
)</code></pre></div>
</div>
<div id="primitives" class="slide section level2">
<h2>Primitives</h2>
<p>Use a GADT to describe the kinds of elements that can exist.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[A]

<span class="kw">case</span> <span class="kw">object</span> JNumT <span class="kw">extends</span> JSchema[Long]
<span class="kw">case</span> <span class="kw">object</span> JBoolT <span class="kw">extends</span> JSchema[Boolean]
<span class="kw">case</span> <span class="kw">object</span> JStrT <span class="kw">extends</span> JSchema[String]</code></pre></div>
</div>
<div id="primitive-serialization" class="slide section level2">
<h2>Primitive serialization</h2>
<p>Use a GADT to describe the kinds of elements that can exist.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[A]

<span class="kw">case</span> <span class="kw">object</span> JNumT <span class="kw">extends</span> JSchema[Long]
<span class="kw">case</span> <span class="kw">object</span> JBoolT <span class="kw">extends</span> JSchema[Boolean]
<span class="kw">case</span> <span class="kw">object</span> JStrT <span class="kw">extends</span> JSchema[String]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> argonaut.<span class="fu">Json</span>
<span class="kw">import</span> argonaut.<span class="fu">Json</span>._

<span class="kw">def</span> serialize[A](schema: JSchema[A], value: A): Json = {
  schema <span class="kw">match</span> {
    <span class="kw">case</span> JBoolT =&gt; <span class="fu">jBool</span>(value)
    <span class="kw">case</span> JStrT  =&gt; <span class="fu">jString</span>(value)
    <span class="kw">case</span> JNumT  =&gt; <span class="fu">jNumber</span>(value)
  }
}</code></pre></div>

</div>
<div id="primitive-parsing" class="slide section level2">
<h2>Primitive parsing</h2>
<p>Create a parser by generating a function between a schema and an <a href="http://argonaut.io">argonaut</a> DecodeJson instance.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[A]

<span class="kw">case</span> <span class="kw">object</span> JNumT <span class="kw">extends</span> JSchema[Long]
<span class="kw">case</span> <span class="kw">object</span> JBoolT <span class="kw">extends</span> JSchema[Boolean]
<span class="kw">case</span> <span class="kw">object</span> JStrT <span class="kw">extends</span> JSchema[String]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> argonaut.<span class="fu">DecodeJson</span>
<span class="kw">import</span> argonaut.<span class="fu">DecodeJson</span>._

<span class="kw">def</span> decoder[A](schema: JSchema[A]): DecodeJson[A] = {
  schema <span class="kw">match</span> {
    <span class="kw">case</span> JBoolT =&gt; BooleanDecodeJson
    <span class="kw">case</span> JStrT  =&gt; StringDecodeJson
    <span class="kw">case</span> JNumT  =&gt; LongDecodeJson
  }
}</code></pre></div>
</div>
<div id="primitive-parsing-1" class="slide section level2">
<h2>Primitive parsing</h2>
<p>Create a parser by generating a function between a schema and an <a href="http://argonaut.io">argonaut</a> DecodeJson instance.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[A]

<span class="kw">case</span> <span class="kw">object</span> JNumT <span class="kw">extends</span> JSchema[Long]
<span class="kw">case</span> <span class="kw">object</span> JBoolT <span class="kw">extends</span> JSchema[Boolean]
<span class="kw">case</span> <span class="kw">object</span> JStrT <span class="kw">extends</span> JSchema[String]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> argonaut.<span class="fu">DecodeJson</span>
<span class="kw">import</span> argonaut.<span class="fu">DecodeJson</span>._


  <span class="kw">def</span> decoder[A](schema: JSchema[A]): DecodeJson[A] = {
    schema <span class="kw">match</span> {
      <span class="kw">case</span> JBoolT =&gt; BooleanDecodeJson
      <span class="kw">case</span> JStrT  =&gt; StringDecodeJson
      <span class="kw">case</span> JNumT  =&gt; LongDecodeJson
    }
  }</code></pre></div>
</div>
<div id="natural-transformations" class="slide section level2">
<h2>Natural Transformations</h2>
<p>Create a parser by generating a <del>function</del> natural transformation between a schema and an <a href="http://argonaut.io">argonaut</a> DecodeJson instance.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[A]

<span class="kw">case</span> <span class="kw">object</span> JNumT <span class="kw">extends</span> JSchema[Long]
<span class="kw">case</span> <span class="kw">object</span> JBoolT <span class="kw">extends</span> JSchema[Boolean]
<span class="kw">case</span> <span class="kw">object</span> JStrT <span class="kw">extends</span> JSchema[String]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> argonaut.<span class="fu">DecodeJson</span>
<span class="kw">import</span> argonaut.<span class="fu">DecodeJson</span>._

<span class="kw">val</span> decoder = <span class="kw">new</span> (JSchema ~&gt; DecodeJson) {
  <span class="kw">def</span> apply[A](schema: JSchema[A]): DecodeJson[A] = {
    schema <span class="kw">match</span> {
      <span class="kw">case</span> JBoolT =&gt; BooleanDecodeJson
      <span class="kw">case</span> JStrT  =&gt; StringDecodeJson
      <span class="kw">case</span> JNumT  =&gt; LongDecodeJson
    }
  }
}</code></pre></div>
</div>
<div id="natural-transformations-1" class="slide section level2">
<h2>Natural Transformations</h2>
<p>With a little rearranging, we can also make serialization a natural transformation.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> serialize[A](schema: JSchema[A], value: A): Json</code></pre></div>
</div>
<div id="natural-transformations-2" class="slide section level2">
<h2>Natural Transformations</h2>
<p>With a little rearranging, we can also make serialization a natural transformation.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> serialize[A](schema: JSchema[A]): A =&gt; Json</code></pre></div>
<div class="incremental">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> serializer: JSchema ~&gt; (? =&gt; Json)</code></pre></div>
</div>
<div class="incremental">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> serializer = <span class="kw">new</span> (JSchema ~&gt; (? =&gt; Json)) {
  <span class="kw">def</span> apply[A](schema: JSchema[A]): A =&gt; Json = {
    schema <span class="kw">match</span> {
      <span class="kw">case</span> JBoolT =&gt; <span class="fu">jBool</span>(_)
      <span class="kw">case</span> JStrT  =&gt; <span class="fu">jString</span>(_)
      <span class="kw">case</span> JNumT  =&gt; <span class="fu">jNumber</span>(_)
    }
  }
}</code></pre></div>
</div>
</div>
<div id="natural-transformations-3" class="slide section level2">
<h2>Natural Transformations</h2>
<p>When we're working at the level of descriptions of data, what we end up writing are natural transformations between our description and value-level functions.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> serializer: JSchema ~&gt; (? =&gt; Json)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> decoder: JSchema ~&gt; JsonDecoder</code></pre></div>
</div>
<div id="natural-transformations-4" class="slide section level2">
<h2>Natural Transformations</h2>
<p>When we're working at the level of descriptions of data, what we end up writing are natural transformations between our description and value-level functions.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> serializer: JSchema ~&gt; (? =&gt; Json)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> decoder: JSchema ~&gt; (Json =&gt; Either[ParseError, ?])</code></pre></div>
</div>
<div id="sequences" class="slide section level2">
<h2>Sequences</h2>
<p>Sequences are simple to describe because the only thing you need to represent is the type of the element.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JVecT[A](elemType: JSchema[A]) <span class="kw">extends</span> JSchema[Vector[A]]</code></pre></div>
</div>
<div id="sequences-1" class="slide section level2">
<h2>Sequences</h2>
<p>Sequences are simple to describe because the only thing you need to represent is the type of the element.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JVecT[A](elemType: JSchema[A]) <span class="kw">extends</span> JSchema[Vector[A]]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> boolsSchema: JSchema[Vector[Boolean]] = <span class="fu">JVecT</span>(JBoolT)</code></pre></div>
</div>
<div id="sequence-serialization" class="slide section level2">
<h2>Sequence serialization</h2>
<p>Sequences are simple to describe because the only thing you need to represent is the type of the element.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JVecT[A](elemType: JSchema[A]) <span class="kw">extends</span> JSchema[Vector[A]]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> boolsSchema: JSchema[Vector[Boolean]] = <span class="fu">JVecT</span>(JBoolT)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> serializer = <span class="kw">new</span> (JSchema ~&gt; (? =&gt; Json)) = {
  <span class="kw">def</span> apply[A](schema: JSchema[A]): A =&gt; Json = {
    schema <span class="kw">match</span> {
      <span class="co">//...</span>
      <span class="kw">case</span> <span class="fu">JVecT</span>(elemSchema) =&gt; 
        value =&gt; <span class="fu">jArray</span>(value.<span class="fu">map</span>(<span class="fu">serializer</span>(elemSchema)))
    }
  }
}</code></pre></div>
</div>
<div id="sequence-parsing" class="slide section level2">
<h2>Sequence parsing</h2>
<p>Sequences are simple to describe because the only thing you need to represent is the type of the element.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JVecT[A](elemType: JSchema[A]) <span class="kw">extends</span> JSchema[Vector[A]]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> boolsSchema: JSchema[Vector[Boolean]] = <span class="fu">JVecT</span>(JBoolT)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> serializer = <span class="kw">new</span> (JSchema ~&gt; (? =&gt; Json)) = {
  <span class="kw">def</span> apply[A](schema: JSchema[A]): A =&gt; Json = {
    schema <span class="kw">match</span> {
      <span class="co">//...</span>
      <span class="kw">case</span> <span class="fu">JVecT</span>(elemSchema) =&gt; 
        value =&gt; <span class="fu">jArray</span>(value.<span class="fu">map</span>(<span class="fu">serializer</span>(elemSchema)))
    }
  }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> decoder = <span class="kw">new</span> (JSchema ~&gt; DecodeJson) {
  <span class="kw">def</span> apply[A](schema: JSchema[A]) = {
    schema <span class="kw">match</span> {
      <span class="co">//...</span>
      <span class="kw">case</span> <span class="fu">JVecT</span>(elemSchema) =&gt; <span class="fu">VectorDecodeJson</span>(<span class="fu">decoder</span>(elemSchema))
    }
  }
}</code></pre></div>
</div>
<div id="records" class="slide section level2">
<h2>Records</h2>
<p>For records, however, we have to be able to relate schema for multiple values of different types.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">Person</span>(
  name: String, 
  birthDate: Instant 
)</code></pre></div>
</div>
<div id="records-1" class="slide section level2">
<h2>Records</h2>
<p>For records, however, we have to be able to relate schema for multiple values of different types.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">Person</span>(
  name: String, 
  birthDate: Instant
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> liftA2[A, B, C, F[_]: Applicative](fa: F[A], fb: F[B])(f: (A, B) =&gt; C): F[C]</code></pre></div>
</div>
<div id="records-2" class="slide section level2">
<h2>Records</h2>
<p>For records, however, we have to be able to relate schema for multiple values of different types.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">Person</span>(
  name: String, 
  birthDate: Instant
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> liftA2[A, B, C, F[_]: Applicative](fa: F[A], fb: F[B])(f: (A, B) =&gt; C): F[C]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> personSchema: JSchema[Person] = <span class="fu">liftA2</span>(JStrT, JNumT) { Person.<span class="fu">apply</span> _ }</code></pre></div>
</div>
<div id="records-3" class="slide section level2">
<h2>Records</h2>
<p>So, how do we define Applicative for this data type?</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[A]

<span class="kw">case</span> <span class="kw">object</span> JStrT <span class="kw">extends</span> JSchema[String]
<span class="kw">case</span> <span class="kw">object</span> JNumT <span class="kw">extends</span> JSchema[Long]
<span class="kw">case</span> <span class="kw">object</span> JBoolT <span class="kw">extends</span> JSchema[Boolean]

<span class="kw">case</span> <span class="kw">class</span> JVecT[A](elemType: JSchema[A]) <span class="kw">extends</span> JSchema[Vector[A]]</code></pre></div>
</div>
<div id="records-4" class="slide section level2">
<h2>Records</h2>
<p>So, how do we define Applicative for this data type?</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[A]

<span class="kw">case</span> <span class="kw">object</span> JStrT <span class="kw">extends</span> JSchema[String]
<span class="kw">case</span> <span class="kw">object</span> JNumT <span class="kw">extends</span> JSchema[Long]
<span class="kw">case</span> <span class="kw">object</span> JBoolT <span class="kw">extends</span> JSchema[Boolean]

<span class="kw">case</span> <span class="kw">class</span> JVecT[A](elemType: JSchema[A]) <span class="kw">extends</span> JSchema[Vector[A]]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Applicative[F[_]] {
  <span class="kw">def</span> pure[A](a: A): F[A]
  <span class="kw">def</span> map[A, B](fa: F[A])(f: A =&gt; B): F[B]
  <span class="kw">def</span> ap[A, B](fa: F[A])(ff: F[A =&gt; B]): F[B]
}</code></pre></div>
<p><code>pure</code> and <code>map</code> don't make any sense!</p>
</div>
<div id="records-take-2" class="slide section level2">
<h2>Records, Take 2</h2>
<p>We need an applicative functor, but maybe not for the whole schema type. What about just for the record (product) types?</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JObjT[A](props: Props[A]) <span class="kw">extends</span> JSchema[A]</code></pre></div>
</div>
<div id="records-take-2-1" class="slide section level2">
<h2>Records, Take 2</h2>
<p>We need an applicative functor, but maybe not for the whole schema type. What about just for the record (product) types?</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JObjT[A](props: Props[A]) <span class="kw">extends</span> JSchema[A]</code></pre></div>
<p>To define our record builder first define a class that captures the name and the schema for a single property.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> PropSchema[O, A](fieldName: String, valueSchema: JSchema[A], accessor: O =&gt; A)</code></pre></div>
</div>
<div id="records-take-2-2" class="slide section level2">
<h2>Records, Take 2</h2>
<p>We need an applicative functor, but maybe not for the whole schema type. What about just for the record (product) types?</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JObjT[A](props: Props[A, A]) <span class="kw">extends</span> JSchema[A]</code></pre></div>
<p>To define our record builder first define a class that captures the name and the schema for a single property.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> PropSchema[O, A](fieldName: String, valueSchema: JSchema[A], accessor: O =&gt; A)</code></pre></div>
<p>Now, wrap <strong>that</strong> up in a data structure for which we can define the applicative operations.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Props[O, A] 

<span class="kw">case</span> <span class="kw">class</span> ApProps[O, A, B](
  prop: PropSchema[O, B], 
  rest: Props[O, B =&gt; A]
) <span class="kw">extends</span> Props[O, A]

<span class="kw">case</span> <span class="kw">class</span> PureProps[O, A](a: A) <span class="kw">extends</span> Props[O, A]</code></pre></div>

</div>
<div id="records-take-2-3" class="slide section level2">
<h2>Records, Take 2</h2>
<p>Is it applicative? We can find out by implementing <code>ap</code>.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> applicative[O] = <span class="kw">new</span> Applicative[Props[O, ?]] {
  <span class="kw">def</span> point[A](a: =&gt; A): Props[O, A] = <span class="fu">PureProps</span>(a)

  <span class="kw">override</span> <span class="kw">def</span> map[A,B](fa: Props[O, A])(f: A =&gt; B): Props[O, B] = {
    fa <span class="kw">match</span> {
      <span class="kw">case</span> <span class="fu">PureProps</span>(a) =&gt; <span class="fu">PureProps</span>(<span class="fu">f</span>(a))
      <span class="kw">case</span> <span class="fu">ApProps</span>(prop, rest) =&gt; <span class="fu">ApProps</span>(prop, <span class="fu">map</span>(rest)(f compose _))
    }
  }

  <span class="kw">def</span> ap[A,B](fa: =&gt; Props[O, A])(ff: =&gt; Props[O, A =&gt; B]): Props[O, B] = {
    ff <span class="kw">match</span> {
      <span class="kw">case</span> <span class="fu">PureProps</span>(f) =&gt; <span class="fu">map</span>(fa)(f)
      <span class="kw">case</span> aprb: ApProps[O, (A =&gt; B), i] =&gt; 
        <span class="fu">ApProps</span>(
          aprb.<span class="fu">prop</span>, 
          <span class="fu">ap</span>(fa) { 
            map[i =&gt; (A =&gt; B), A =&gt; (i =&gt; B)](aprb.<span class="fu">rest</span>) { 
              (g: i =&gt; (A =&gt; B)) =&gt; { (a: A) =&gt; { (i: i) =&gt; <span class="fu">g</span>(i)(a) } } <span class="co">// this is just flip</span>
            }
          }
        )
    }
  }
}</code></pre></div>

</div>
<div id="records-take-2-4" class="slide section level2">
<h2>Records, Take 2</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Props[O, A] 

<span class="kw">case</span> <span class="kw">class</span> PureProps[O, A](a: A) <span class="kw">extends</span> Props[O, A]

<span class="kw">case</span> <span class="kw">class</span> ApProps[O, A, B](
  prop: PropSchema[O, B], 
  rest: Props[O, B =&gt; A]
) <span class="kw">extends</span> Props[O, A]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JObjT[A](props: Props[A, A]) <span class="kw">extends</span> JSchema[A]

<span class="kw">case</span> <span class="kw">class</span> PropSchema[O, A](fieldName: String, valueSchema: JSchema[A], accessor: O =&gt; A)</code></pre></div>

</div>
<div id="records-take-2-5" class="slide section level2">
<h2>Records, Take 2</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Props[F[_, _], O, A] 

<span class="kw">case</span> <span class="kw">class</span> PureProps[F[_, _], O, A](a: A) <span class="kw">extends</span> Props[F, O, A]

<span class="kw">case</span> <span class="kw">class</span> ApProps[F[_, _], O, A, B](
  prop: F[O, B], 
  rest: Props[F, O, B =&gt; A]
) <span class="kw">extends</span> Props[F, O, A]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JObjT[A](props: Props[PropSchema, A, A]) <span class="kw">extends</span> JSchema[A]

<span class="kw">case</span> <span class="kw">class</span> PropSchema[O, A](fieldName: String, valueSchema: JSchema[A], accessor: O =&gt; A)</code></pre></div>

</div>
<div id="records-take-2-6" class="slide section level2">
<h2>Records, Take 2</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Props[F[_], A] 

<span class="kw">case</span> <span class="kw">class</span> PureProps[F[_], A](a: A) <span class="kw">extends</span> Props[F, A]

<span class="kw">case</span> <span class="kw">class</span> ApProps[F[_], A, B](
  prop: F[B], 
  rest: Props[F, B =&gt; A]
) <span class="kw">extends</span> Props[F, A]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JObjT[A](props: Props[PropSchema[A, ?], A]) <span class="kw">extends</span> JSchema[A]

<span class="kw">case</span> <span class="kw">class</span> PropSchema[O, A](fieldName: String, valueSchema: JSchema[A], accessor: O =&gt; A)</code></pre></div>
</div>
<div id="records-take-3" class="slide section level2">
<h2>Records, Take 3</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> FreeAp[F[_], A] 

<span class="kw">case</span> <span class="kw">class</span> Pure[F[_], A](a: A) <span class="kw">extends</span> FreeAp[F, A]

<span class="kw">case</span> <span class="kw">class</span> Ap[F[_], A, B](
  head: F[B], 
  tail: FreeAp[F, B =&gt; A]
) <span class="kw">extends</span> FreeAp[F, A]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JObjT[A](props: FreeAp[PropSchema[A, ?], A]) <span class="kw">extends</span> JSchema[A]

<span class="kw">case</span> <span class="kw">class</span> PropSchema[O, A](fieldName: String, valueSchema: JSchema[A], accessor: O =&gt; A)</code></pre></div>
</div>
<div id="records-take-3-1" class="slide section level2">
<h2>Records, Take 3</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> scalaz.<span class="fu">FreeAp</span>

<span class="kw">case</span> <span class="kw">class</span> JObjT[A](props: FreeAp[PropSchema[A, ?], A]) <span class="kw">extends</span> JSchema[A]

<span class="kw">case</span> <span class="kw">class</span> PropSchema[O, A](fieldName: String, valueSchema: JSchema[A], accessor: O =&gt; A)</code></pre></div>
</div>
<div id="record-serialization" class="slide section level2">
<h2>Record serialization</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> serializer = <span class="kw">new</span> (JSchema ~&gt; (? =&gt; Json)) = {
  <span class="kw">def</span> apply[A](schema: JSchema[A]): A =&gt; Json = {
    schema <span class="kw">match</span> {
      <span class="kw">case</span> <span class="fu">JObjT</span>(fa) =&gt; <span class="fu">serializeObj</span>(fa, _: A)
      <span class="co">//...</span>
    }
  }
}</code></pre></div>
</div>
<div id="record-serialization-1" class="slide section level2">
<h2>Record serialization</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> serializer = <span class="kw">new</span> (JSchema ~&gt; (? =&gt; Json)) = {
  <span class="kw">def</span> apply[A](schema: JSchema[A]): A =&gt; Json = {
    schema <span class="kw">match</span> {
      <span class="kw">case</span> <span class="fu">JObjT</span>(fa) =&gt; <span class="fu">serializeObj</span>(fa, _: A)
      <span class="co">//...</span>
    }
  }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">def</span> serializeObj[A](rb: FreeAp[PropSchema[A, ?], A], value: A): Json = {
    <span class="fu">jObject</span>(
      rb.<span class="fu">foldMap</span>[State[JsonObject, ?]](
        <span class="kw">new</span> (PropSchema[A, ?] ~&gt; State[JsonObject, ?]) {
          <span class="kw">def</span> apply[B](ps: PropSchema[A, B]): State[JsonObject, B] = {
            <span class="kw">val</span> elem: B = ps.<span class="fu">accessor</span>(value)
            <span class="kw">for</span> {
              obj &lt;- get
              _ &lt;- <span class="fu">put</span>(obj + (ps.<span class="fu">fieldName</span>, <span class="fu">serializer</span>(ps.<span class="fu">valueSchema</span>)(elem)))
            } <span class="kw">yield</span> elem
          }
        }
      ).<span class="fu">exec</span>(JsonObject.<span class="fu">empty</span>)
    )
  }</code></pre></div>
</div>
<div id="record-decoding" class="slide section level2">
<h2>Record decoding</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">def</span> decodeObj[A](rb: FreeAp[PropSchema[A, ?], A]): DecodeJson[A] = {
    <span class="kw">implicit</span> <span class="kw">val</span> djap: Applicative[DecodeJson] = <span class="kw">new</span> Applicative[DecodeJson] {
      <span class="kw">def</span> point[A](a: =&gt; A) = <span class="fu">DecodeJson</span>(_ =&gt; DecodeResult.<span class="fu">ok</span>(a))
      <span class="kw">def</span> ap[A, B](fa: =&gt; DecodeJson[A])(ff: =&gt; DecodeJson[A =&gt; B]): DecodeJson[B] = {
        fa.<span class="fu">flatMap</span>(a =&gt; ff.<span class="fu">map</span>(_(a)))
      }
    }

    rb.<span class="fu">foldMap</span>(
      <span class="kw">new</span> (PropSchema[A, ?] ~&gt; DecodeJson) {
        <span class="kw">def</span> apply[B](ps: PropSchema[A, B]): DecodeJson[B] = <span class="fu">DecodeJson</span>(
          _.<span class="fu">downField</span>(ps.<span class="fu">fieldName</span>).<span class="fu">as</span>(<span class="fu">decoder</span>(ps.<span class="fu">valueSchema</span>))
        )
      }
    )
  }</code></pre></div>
</div>
<div id="sum-types" class="slide section level2">
<h2>Sum types</h2>
<p>We represent sum types as a list of alternatives.</p>
<p>Each constructor of the sum type is associated with a value that maps from the arguments demanded by that constructor to a value of the sum type.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JSumT[A](alternatives: List[Alt[A, B] <span class="kw">forSome</span> { <span class="kw">type</span> B }]) <span class="kw">extends</span> JSchema[A]

<span class="kw">case</span> <span class="kw">class</span> Alt[A, B](id: String, base: JSchema[B], review: B =&gt; A, preview: A =&gt; Option[B])</code></pre></div>
</div>
<div id="sum-types-1" class="slide section level2">
<h2>Sum types</h2>
<p>We represent sum types as a list of alternatives.</p>
<p>Each constructor of the sum type is associated with a value that maps from the arguments demanded by that constructor to a value of the sum type.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JSumT[A](alternatives: List[Alt[A, B] <span class="kw">forSome</span> { <span class="kw">type</span> B }]) <span class="kw">extends</span> JSchema[A]

<span class="kw">case</span> <span class="kw">class</span> Alt[A, B](id: String, base: JSchema[B], review: B =&gt; A, preview: A =&gt; Option[B])</code></pre></div>
<p>The combination of 'review' and 'preview' is better expressed as a prism.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JSumT[A](alternatives: List[Alt[A, B] <span class="kw">forSome</span> { <span class="kw">type</span> B }]) <span class="kw">extends</span> JSchema[A]

<span class="kw">case</span> <span class="kw">class</span> Alt[A, B](id: String, base: JSchema[B], prism: Prism[A, B])</code></pre></div>
</div>
<div id="sum-types-2" class="slide section level2">
<h2>Sum types</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JSumT[A](alternatives: List[Alt[A, B] <span class="kw">forSome</span> { <span class="kw">type</span> B }]) <span class="kw">extends</span> JSchema[A]

<span class="kw">case</span> <span class="kw">class</span> Alt[A, B](id: String, base: JSchema[B], prism: Prism[A, B])</code></pre></div>
</div>
<div id="sum-types-3" class="slide section level2">
<h2>Sum types</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JSumT[A](alternatives: List[Alt[A, B] <span class="kw">forSome</span> { <span class="kw">type</span> B }]) <span class="kw">extends</span> JSchema[A]

<span class="kw">case</span> <span class="kw">class</span> Alt[A, B](id: String, base: JSchema[B], prism: Prism[A, B])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> monocle.<span class="fu">macros</span>._

<span class="kw">case</span> <span class="kw">object</span> User <span class="kw">extends</span> Role {
  <span class="kw">val</span> prism = GenPrism[Role, User.<span class="fu">type</span>]
}

<span class="co">// &quot;user&quot;: {}</span>

<span class="kw">val</span> userRoleAlt = Alt[Role, Unit](
  <span class="st">&quot;user&quot;</span>, 
  <span class="fu">JObjT</span>(FreeAp.<span class="fu">pure</span>(())), 
  User.<span class="fu">prism</span> composeIso GenIso.<span class="fu">unit</span>[User.<span class="fu">type</span>]
)</code></pre></div>
</div>
<div id="sum-types-4" class="slide section level2">
<h2>Sum types</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JSumT[A](alternatives: List[Alt[A, B] <span class="kw">forSome</span> { <span class="kw">type</span> B }]) <span class="kw">extends</span> JSchema[A]

<span class="kw">case</span> <span class="kw">class</span> Alt[A, B](id: String, base: JSchema[B], prism: Prism[A, B])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> monocle.<span class="fu">macros</span>._

<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Administrator</span>(department: String) <span class="kw">extends</span> Role
<span class="kw">object</span> Administrator {
  <span class="kw">val</span> prism = GenPrism[Role, Administrator]
}

<span class="co">// {</span>
<span class="co">//   &quot;admin&quot;: { &quot;department&quot;: &quot;windmill-tilting&quot; }</span>
<span class="co">// } </span>

<span class="kw">val</span> adminRoleAlt = Alt[Role, String](
  <span class="st">&quot;admin&quot;</span>, 
  <span class="fu">JObjT</span>(FreeAp.<span class="fu">lift</span>(<span class="fu">PropSchema</span>(<span class="st">&quot;department&quot;</span>, JStrT, identity))), 
  Administrator.<span class="fu">prism</span> composeIso GenIso[Administrator, String]
)</code></pre></div>
</div>
<div id="sum-types-5" class="slide section level2">
<h2>Sum types</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> JSumT[A](alternatives: List[Alt[A, B] <span class="kw">forSome</span> { <span class="kw">type</span> B }]) <span class="kw">extends</span> JSchema[A]

<span class="kw">case</span> <span class="kw">class</span> Alt[A, B](id: String, base: JSchema[B], prism: Prism[A, B])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> monocle.<span class="fu">macros</span>._

<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Administrator</span>(department: String) <span class="kw">extends</span> Role
<span class="kw">object</span> Administrator {
  <span class="kw">val</span> prism = GenPrism[Role, Administrator]
}

<span class="co">// {</span>
<span class="co">//   &quot;admin&quot;: { &quot;department&quot;: &quot;windmill-tilting&quot; }</span>
<span class="co">// } </span>

<span class="kw">val</span> adminRoleAlt = Alt[Role, String](
  <span class="st">&quot;admin&quot;</span>, 
  <span class="fu">JObjT</span>(FreeAp.<span class="fu">lift</span>(<span class="fu">PropSchema</span>(<span class="st">&quot;department&quot;</span>, JStrT, identity))), 
  Administrator.<span class="fu">prism</span> composeIso GenIso[Administrator, String]
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> roleSchema: JSchema[Role] = <span class="fu">JSumT</span>(userRoleAlt :: adminRoleAlt :: Nil)</code></pre></div>
</div>
<div id="sum-type-serialization" class="slide section level2">
<h2>Sum type serialization</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> serializer = <span class="kw">new</span> (JSchema ~&gt; (? =&gt; Json)) = {
  <span class="kw">def</span> apply[A](schema: JSchema[A]): A =&gt; Json = {
    schema <span class="kw">match</span> {
      <span class="kw">case</span> <span class="fu">JSumT</span>(alts) =&gt; 
        (value: A) =&gt; alts.<span class="fu">flatMap</span>({
          <span class="kw">case</span> <span class="fu">Alt</span>(id, base, prism) =&gt; 
            prism.<span class="fu">getOption</span>(value).<span class="fu">map</span>(<span class="fu">serializer</span>(base)).<span class="fu">toList</span> map { json =&gt;
              <span class="fu">jObject</span>(JsonObject.<span class="fu">single</span>(id, json))
            }
        }).<span class="fu">head</span>

      <span class="co">//...</span>
    }
}</code></pre></div>

</div>
<div id="sum-type-parsing" class="slide section level2">
<h2>Sum type parsing</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> decoder = <span class="kw">new</span> (JSchema ~&gt; DecodeJson) {
  <span class="kw">def</span> apply[A](schema: JSchema[A]) = {
    schema <span class="kw">match</span> {
      <span class="co">//...</span>
      <span class="kw">case</span> <span class="fu">JSumT</span>(alts) =&gt; DecodeJson { (c: HCursor) =&gt; 
        <span class="kw">val</span> results = <span class="kw">for</span> {
          fields &lt;- c.<span class="fu">fields</span>.<span class="fu">toList</span>
          altResult &lt;- alts flatMap {
            <span class="kw">case</span> <span class="fu">Alt</span>(id, base, prism) =&gt;
              fields.<span class="fu">exists</span>(_ == id).<span class="fu">option</span>(
                c.<span class="fu">downField</span>(id).<span class="fu">as</span>(<span class="fu">decoder</span>(base)).<span class="fu">map</span>(prism.<span class="fu">reverseGet</span>)
              ).<span class="fu">toList</span>
          }
        } <span class="kw">yield</span> altResult 

        <span class="kw">val</span> altIds = alts.<span class="fu">map</span>(_.<span class="fu">id</span>)
        results <span class="kw">match</span> {
          <span class="kw">case</span> x :: Nil =&gt; x
          <span class="kw">case</span> Nil =&gt; DecodeResult.<span class="fu">fail</span>(s<span class="st">&quot;No fields found matching any of ${altIds}&quot;</span>, c.<span class="fu">history</span>)
          <span class="kw">case</span> xs =&gt; DecodeResult.<span class="fu">fail</span>(s<span class="st">&quot;More than one matching field found among ${altIds}&quot;</span>, c.<span class="fu">history</span>)
        }
      }
    }
  }
}</code></pre></div>
</div>
<div id="what-else-can-we-do" class="slide section level2">
<h2>What else can we do?</h2>
<ul>
<li>ScalaCheck <a href="https://github.com/rickynils/scalacheck/blob/master/src/main/scala/org/scalacheck/Gen.scala">Gen</a> instances</li>
<li>Binary serialization using <a href="https://github.com/scodec/scodec">scodec</a></li>
<li><a href="https://app-dev.pellucid.com">User interfaces</a></li>
<li>Interpret to whatever Applicative you want, really.</li>
</ul>

</div>
<div id="so...-whats-the-catch" class="slide section level2">
<h2>So... what's the catch?</h2>
<ul>
<li>Fixed set of primitives is overly limiting</li>
<li>Unable to provide additional metadata about values/fields without altering the schema algebra</li>
</ul>
<p>So let's fix these things.</p>
</div>
<div id="problem-1-primitives" class="slide section level2">
<h2>Problem 1: Primitives</h2>
<p>We started off by defining schema for String, Long, and Boolean. This clearly isn't enough. For example, I want to be able to define a schema where date values, represented in JSON as strings, are first-class.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[A]

<span class="kw">case</span> <span class="kw">object</span> JStrT <span class="kw">extends</span> JSchema[String]
<span class="kw">case</span> <span class="kw">object</span> JNumT <span class="kw">extends</span> JSchema[Long]
<span class="kw">case</span> <span class="kw">object</span> JBoolT <span class="kw">extends</span> JSchema[Boolean]
<span class="kw">case</span> <span class="kw">object</span> JDateT <span class="kw">extends</span> JSchema[DateTime]

<span class="kw">case</span> <span class="kw">class</span> JVecT[A](elemType: JSchema[A]) <span class="kw">extends</span> JSchema[Vector[A]]

<span class="kw">case</span> <span class="kw">class</span> JSumT[A](alternatives: List[Alt[A, B] <span class="kw">forSome</span> { <span class="kw">type</span> B }]) <span class="kw">extends</span> JSchema[A]

<span class="kw">case</span> <span class="kw">class</span> JObjT[A](props: FreeAp[PropSchema[A, ?], A]) <span class="kw">extends</span> JSchema[A]</code></pre></div>
</div>
<div id="problem-1-primitives-1" class="slide section level2">
<h2>Problem 1: Primitives</h2>
<p>We started off by defining schema for String, Long, and Boolean. This clearly isn't enough. For example, I want to be able to define a schema where date values, represented in JSON as strings, are first-class.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[P[_], A]

<span class="kw">case</span> <span class="kw">class</span> JPrimT[P[_], A](prim: P[A]) <span class="kw">extends</span> JSchema[P, A]




<span class="kw">case</span> <span class="kw">class</span> JVecT[P[_], A](elemType: JSchema[P, A]) <span class="kw">extends</span> JSchema[P, Vector[A]]

<span class="kw">case</span> <span class="kw">class</span> JSumT[P[_], A](alternatives: List[Alt[P, A, B] <span class="kw">forSome</span> { <span class="kw">type</span> B }]) <span class="kw">extends</span> JSchema[P, A]

<span class="kw">case</span> <span class="kw">class</span> JObjT[P[_], A](props: FreeAp[PropSchema[P, A, ?], A]) <span class="kw">extends</span> JSchema[P, A]</code></pre></div>
</div>
<div id="problem-1-primitives-2" class="slide section level2">
<h2>Problem 1: Primitives</h2>
<p>Then, we define a separate GADT just defining the primitive types we're interested in.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JsonPrim[A]
<span class="kw">case</span> <span class="kw">object</span> JStrT <span class="kw">extends</span> JsonPrim[String]
<span class="kw">case</span> <span class="kw">object</span> JNumT <span class="kw">extends</span> JsonPrim[Long]
<span class="kw">case</span> <span class="kw">object</span> JBoolT <span class="kw">extends</span> JsonPrim[Boolean]
<span class="kw">case</span> <span class="kw">object</span> JDateT <span class="kw">extends</span> JsonPrim[DateTime]</code></pre></div>
</div>
<div id="problem-1-primitives-3" class="slide section level2">
<h2>Problem 1: Primitives</h2>
<p>Then, we define a separate GADT just defining the primitive types we're interested in.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JsonPrim[A]
<span class="kw">case</span> <span class="kw">object</span> JStrT <span class="kw">extends</span> JsonPrim[String]
<span class="kw">case</span> <span class="kw">object</span> JNumT <span class="kw">extends</span> JsonPrim[Long]
<span class="kw">case</span> <span class="kw">object</span> JBoolT <span class="kw">extends</span> JsonPrim[Boolean]
<span class="kw">case</span> <span class="kw">object</span> JDateT <span class="kw">extends</span> JsonPrim[DateTime]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[P[_], A]

<span class="kw">type</span> MySchema[A] = JSchema[JsonPrim, A]</code></pre></div>
</div>
<div id="problem-1-primitives-4" class="slide section level2">
<h2>Problem 1: Primitives</h2>
<p>In order to define serialization in the presence of this new layer of abstraction, we're going to need a bit more machinery:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> ToJson[S[_]] {
  <span class="kw">def</span> serializer: S ~&gt; (? =&gt; Json)
}

<span class="kw">trait</span> FromJson[S[_]] {
  <span class="kw">def</span> decoder: S ~&gt; DecodeJson
}</code></pre></div>
</div>
<div id="problem-1-primitives-5" class="slide section level2">
<h2>Problem 1: Primitives</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">def</span> jSchemaToJson[P[_]: ToJson] = <span class="kw">new</span> ToJson[JSchema[P, ?]] {
  <span class="kw">val</span> serializer = <span class="kw">new</span> (JSchema[P, ?] ~&gt; (? =&gt; Json)) {
    <span class="kw">def</span> apply[A](schema: JSchema[P, A]): A =&gt; Json = {
      schema <span class="kw">match</span> {
        <span class="kw">case</span> <span class="fu">JPrimT</span>(p) =&gt; implicitly[ToJson[P]].<span class="fu">serializer</span>(p)

        <span class="co">// handling the other constructors stays the same</span>
      }
    }
  }
}

<span class="kw">implicit</span> <span class="kw">val</span> JsonPrimToJson = <span class="kw">new</span> ToJson[JsonPrim] {
  <span class="kw">val</span> serializer = <span class="kw">new</span> (JsonPrim ~&gt; (? =&gt; Json)) {
    <span class="kw">def</span> apply[A](p: JsonPrim[A]): A =&gt; Json = {
      schema <span class="kw">match</span> {
        <span class="kw">case</span> JStrT  =&gt; <span class="fu">jString</span>(_)
        <span class="kw">case</span> JNumT  =&gt; <span class="fu">jNumber</span>(_)
        <span class="kw">case</span> JBoolT =&gt; <span class="fu">jBool</span>(_)
        <span class="kw">case</span> JDateT =&gt; (dt: DateTime) =&gt; <span class="fu">jString</span>(dt.<span class="fu">toString</span>)
      }
    }
  }
}</code></pre></div>
</div>
<div id="problem-1-primitives-6" class="slide section level2">
<h2>Problem 1: Primitives</h2>
<p>Having done this, we get an added bonus: We can use coproducts to compose sets of primitives!</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">def</span> primCoToJson[P[_]: ToJson, Q[_]: ToJson] = <span class="kw">new</span> ToJson[Coproduct[P, Q, ?]] {
  <span class="kw">val</span> serializer = <span class="kw">new</span> (Coproduct[P, Q, ?] ~&gt; (A =&gt; Json)) {
    <span class="kw">def</span> apply[A](p: Coproduct[P, Q, A]): A =&gt; Json = {
      p.<span class="fu">run</span>.<span class="fu">fold</span>(
        implicitly[ToJson[P]].<span class="fu">serializer</span>,
        implicitly[ToJson[Q]].<span class="fu">serializer</span>
      )
    }
  }
}

<span class="kw">implicit</span> <span class="kw">def</span> primCoFromJson[P[_]: FromJson, Q[_]: FromJson] = <span class="kw">new</span> FromJson[Coproduct[P, Q, ?]] {
  <span class="kw">val</span> decoder = <span class="kw">new</span> (Coproduct[P, Q, ?] ~&gt; DecodeJson) {
    <span class="kw">def</span> apply[A](p: Coproduct[P, Q, A]): DecodeJson[A] = {
      p.<span class="fu">run</span>.<span class="fu">fold</span>(
        implicitly[FromJson[P]].<span class="fu">decoder</span>,
        implicitly[FromJson[Q]].<span class="fu">decoder</span>
      )
    }
  }
}</code></pre></div>
</div>
<div id="either-and-coproduct" class="slide section level2">
<h2>Either and Coproduct</h2>
<p><code>Either[A, B]</code> allows you to take two sum types and create a new sum type whose inhabitants are the union of the inhabitants of <code>A</code> and the inhabitants of <code>B</code>.</p>
<p><code>Coproduct[F[_], G[_]]</code> allows you to take two <strong>descriptions</strong> of types and create a new <strong>description</strong> which can describe values using either of the nested descriptions.</p>
</div>
<div id="problem-2-annotations" class="slide section level2">
<h2>Problem 2: Annotations</h2>
<ul>
<li>Nodes of the JSchema tree don't currently contain enough information to generate interesting json-schema.
<ul>
<li>titles</li>
<li>min/max length of arrays</li>
<li>property order</li>
<li>formatting metadata</li>
<li>etc.</li>
</ul></li>
<li>We might want different kinds of metadata for different applications.</li>
</ul>
</div>
<div id="problem-2-annotations-1" class="slide section level2">
<h2>Problem 2: Annotations</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[P[_], I]

<span class="kw">case</span> <span class="kw">class</span> JPrimT[P[_], I](prim: P[I]) <span class="kw">extends</span> JSchema[P, I]

<span class="kw">case</span> <span class="kw">class</span> JVecT[P[_], I](elemType: JSchema[P, I]) <span class="kw">extends</span> JSchema[P, Vector[I]]

<span class="kw">case</span> <span class="kw">class</span> JSumT[P[_], I](alternatives: List[Alt[P, I, J] <span class="kw">forSome</span> { <span class="kw">type</span> J }]) <span class="kw">extends</span> JSchema[P, I]

<span class="kw">case</span> <span class="kw">class</span> JObjT[P[_], I](props: FreeAp[PropSchema[P, I, ?], I]) <span class="kw">extends</span> JSchema[P, I]</code></pre></div>
</div>
<div id="problem-2-annotations-2" class="slide section level2">
<h2>Problem 2: Annotations</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[A, P[_], I]

<span class="kw">case</span> <span class="kw">class</span> JPrimT[A, P[_], I](ann: A, prim: P[I]) <span class="kw">extends</span> JSchema[A, P, I]

<span class="kw">case</span> <span class="kw">class</span> JVecT[A, P[_], I](ann: A, elemType: JSchema[A, P, I]) <span class="kw">extends</span> JSchema[A, P, Vector[I]]

<span class="kw">case</span> <span class="kw">class</span> JSumT[A, P[_], I](ann: A, alternatives: List[Alt[A, P, I, J] <span class="kw">forSome</span> { <span class="kw">type</span> J }]) <span class="kw">extends</span> JSchema[A, P, I]

<span class="kw">case</span> <span class="kw">class</span> JObjT[A, P[_], I](ann: A, props: FreeAp[PropSchema[A, P, I, ?], I]) <span class="kw">extends</span> JSchema[A, P, I]</code></pre></div>
<p>This is a bit messy and involves a bunch of redundancy. It will work; it just doesn't seem ideal.</p>
</div>
<div id="directly-recusive-data" class="slide section level2">
<h2>Directly recusive data</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> <span class="fu">Prof</span>(
  name: String,
  students: List[Prof]
)</code></pre></div>
</div>
<div id="no-longer-directly-recusive-data" class="slide section level2">
<h2>No longer directly recusive data</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> ProfF[S](
  name: String,
  students: List[S]
)</code></pre></div>
</div>
<div id="reintroducing-recursion-with-fix" class="slide section level2">
<h2>Reintroducing recursion with Fix</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> ProfF[S](
  name: String,
  students: List[S]
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> Fix[F[_]](f: F[Fix[F]])

<span class="kw">type</span> Prof = Fix[ProfF]</code></pre></div>
</div>
<div id="annotating-a-tree-with-cofree" class="slide section level2">
<h2>Annotating a tree with Cofree</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> ProfF[S](
  name: String,
  students: List[S]
)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> Fix[F[_]](f: F[Fix[F]])

<span class="kw">type</span> Prof = Fix[ProfF]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> Cofree[F[_], A](f: F[Cofree[F, A]], a: A)

<span class="kw">type</span> IdProf = Cofree[ProfF, Int]</code></pre></div>
<p>Hat tip to Rob Norris, go watch his talk <a href="https://www.youtube.com/watch?v=7xSfLPD6tiQ">here</a></p>
</div>
<div id="annotating-a-tree-with-cofree-1" class="slide section level2">
<h2>Annotating a tree with Cofree</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[S, P[_], I]

<span class="kw">case</span> <span class="kw">class</span> JVecT[S, P[_], I](elemType: S) <span class="kw">extends</span> JSchema[S, P, Vector[I]]</code></pre></div>
<p>Does this work?</p>

</div>
<div id="annotating-a-tree-with-cofree-hcofree" class="slide section level2">
<h2>Annotating a tree with <del>Cofree</del> HCofree</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[F[_], P[_], I]

<span class="kw">case</span> <span class="kw">class</span> JVecT[F[_], P[_], I](elemType: F[I]) <span class="kw">extends</span> JSchema[F, P, Vector[I]]</code></pre></div>
</div>
<div id="annotating-a-tree-with-cofree-hcofree-1" class="slide section level2">
<h2>Annotating a tree with <del>Cofree</del> HCofree</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[F[_], P[_], I]

<span class="kw">case</span> <span class="kw">class</span> JVecT[F[_], P[_], I](elemType: F[I]) <span class="kw">extends</span> JSchema[F, P, Vector[I]]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> HFix[F[_[_], _], I](unfix: F[HFix[F, ?], I])</code></pre></div>
</div>
<div id="annotating-a-tree-with-cofree-hcofree-2" class="slide section level2">
<h2>Annotating a tree with <del>Cofree</del> HCofree</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[F[_], P[_], I]

<span class="kw">case</span> <span class="kw">class</span> JVecT[F[_], P[_], I](elemType: F[I]) <span class="kw">extends</span> JSchema[F, P, Vector[I]]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> HFix[F[_[_], _], I](unfix: F[HFix[F, ?], I])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> Schema[P[_]] = HFix[JSchema[?[_], P, ?]]</code></pre></div>
</div>
<div id="annotating-a-tree-with-cofree-hcofree-3" class="slide section level2">
<h2>Annotating a tree with <del>Cofree</del> HCofree</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[F[_], P[_], I]

<span class="kw">case</span> <span class="kw">class</span> JVecT[F[_], P[_], I](elemType: F[I]) <span class="kw">extends</span> JSchema[F, P, Vector[I]]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> HFix[F[_[_], _], I](unfix: F[HFix[F, ?], I])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> Schema[P[_]] = HFix[JSchema[?[_], P, ?]]</code></pre></div>
<p>To add annotations, use HCofree instead of HFix</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> HCofree[A, F[_[_], _], I](a: A, uncf: F[HCofree[A, F, ?], I])</code></pre></div>
</div>
<div id="annotating-a-tree-with-cofree-hcofree-4" class="slide section level2">
<h2>Annotating a tree with <del>Cofree</del> HCofree</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> JSchema[F[_], P[_], I]

<span class="kw">case</span> <span class="kw">class</span> JVecT[F[_], P[_], I](elemType: F[I]) <span class="kw">extends</span> JSchema[F, P, Vector[I]]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> HFix[F[_[_], _], I](unfix: F[HFix[F, ?], I])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> Schema[P[_]] = HFix[JSchema[?[_], P, ?]]</code></pre></div>
<p>To add annotations, use HCofree instead of HFix</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> HCofree[A, F[_[_], _], I](a: A, uncf: F[HCofree[A, F, ?], I])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> AnnSchema[P[_], A] = HCofree[A, JSchema[?[_], P, ?]]</code></pre></div>
</div>
<div id="rewriting-our-interpreters" class="slide section level2">
<h2>Rewriting our interpreters</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> Schema[P[_]] = HFix[JSchema[?[_], P, ?]]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">def</span> jSchemaToJson[P[_]: ToJson] = <span class="kw">new</span> ToJson[Schema[P, ?]] {
  <span class="kw">val</span> serializer = <span class="kw">new</span> (Schema[P, ?] ~&gt; (? =&gt; Json)) = {
    <span class="kw">def</span> apply[I](schema: Schema[P, I]): I =&gt; Json = {
      schema.<span class="fu">unfix</span> <span class="kw">match</span> {
        <span class="kw">case</span> <span class="fu">JSumT</span>(alts) =&gt; 
          (value: I) =&gt; alts.<span class="fu">flatMap</span>({ 
            <span class="kw">case</span> <span class="fu">Alt</span>(id, base, prism) =&gt; 
              prism.<span class="fu">getOption</span>(value).<span class="fu">map</span>(<span class="fu">serializer</span>(base)).<span class="fu">toList</span> map { 
                <span class="fu">jObject</span>(JsonObject.<span class="fu">single</span>(id, _))
              }
          }).<span class="fu">head</span>

        <span class="co">// ...</span>
      }
    }
  }
}</code></pre></div>
</div>
<div id="hfix-and-hcofree" class="slide section level2">
<h2>HFix and HCofree</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> HFix[F[_[_], _], I](unfix: F[HFix[F, ?], I])

<span class="kw">case</span> <span class="kw">class</span> HCofree[A, F[_[_], _], I](a: A, uncf: F[HCofree[A, F, ?], I])</code></pre></div>
</div>
<div id="hfix-and-hcofree-1" class="slide section level2">
<h2>HFix and HCofree</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> HFix[F[_[_], _], I](unfix: F[HFix[F, ?], I])

<span class="kw">case</span> <span class="kw">class</span> HCofree[A, F[_[_], _], I](a: A, uncf: F[HCofree[A, F, ?], I])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> forget[A, F[_[_], _], I](c: HCofree[A, F, I]): HFix[F, I]</code></pre></div>
</div>
<div id="hfix-and-hcofree-2" class="slide section level2">
<h2>HFix and HCofree</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> HFix[F[_[_], _], I](unfix: F[HFix[F, ?], I])

<span class="kw">case</span> <span class="kw">class</span> HCofree[A, F[_[_], _], I](a: A, uncf: F[HCofree[A, F, ?], I])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> forget[A, F[_[_], _]]: (HCofree[A, F, ?] ~&gt; HFix[F, ?])</code></pre></div>
</div>
<div id="hfix-and-hcofree-3" class="slide section level2">
<h2>HFix and HCofree</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> HFix[F[_[_], _], I](unfix: F[HFix[F, ?], I])

<span class="kw">case</span> <span class="kw">class</span> HCofree[A, F[_[_], _], I](a: A, uncf: F[HCofree[A, F, ?], I])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> forget[A, F[_[_], _]]: (HCofree[A, F, ?] ~&gt; HFix[F, ?]) = 
  <span class="kw">new</span> (HCofree[A, F, ?] ~&gt; HFix[F, ?]) {
    <span class="kw">def</span> apply[I](c: HCofree[A, F, I]): HFix[F, I] = {
      c.<span class="fu">uncf</span> <span class="co">// this only discards one layer of annotation!</span>
    }
  }</code></pre></div>
</div>
<div id="hfix-and-hcofree-4" class="slide section level2">
<h2>HFix and HCofree</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> HFix[F[_[_], _], I](unfix: F[HFix[F, ?], I])

<span class="kw">case</span> <span class="kw">class</span> HCofree[A, F[_[_], _], I](a: A, uncf: F[HCofree[A, F, ?], I])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> forget[A, F[_[_], _]: HFunctor]: (HCofree[A, F, ?] ~&gt; HFix[F, ?]) = 
  <span class="kw">new</span> (HCofree[A, F, ?] ~&gt; HFix[F, ?]) { self =&gt; 
    <span class="kw">def</span> apply[I](c: HCofree[A, F, I]): HFix[F, I] = {
      <span class="fu">HFix</span>(implicitly[HFunctor[F]].<span class="fu">hfmap</span>(self)(c.<span class="fu">uncf</span>))
    }
  }
}</code></pre></div>
</div>
<div id="hfix-and-hcofree-5" class="slide section level2">
<h2>HFix and HCofree</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> HFix[F[_[_], _], I](unfix: F[HFix[F, ?], I])

<span class="kw">case</span> <span class="kw">class</span> HCofree[A, F[_[_], _], I](a: A, uncf: F[HCofree[A, F, ?], I])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> forget[A, F[_[_], _]: HFunctor]: (HCofree[A, F, ?] ~&gt; HFix[F, ?]) = 
  <span class="kw">new</span> (HCofree[A, F, ?] ~&gt; HFix[F, ?]) { self =&gt; 
    <span class="kw">def</span> apply[I](c: HCofree[A, F, I]): HFix[F, I] = {
      <span class="fu">HFix</span>(implicitly[HFunctor[F]].<span class="fu">hfmap</span>(self)(c.<span class="fu">uncf</span>))
    }
  }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> HFunctor[F[_[_], _]] {
  <span class="kw">def</span> hfmap[M[_], N[_]](nt: M ~&gt; N): F[M, ?] ~&gt; F[N, ?]
}</code></pre></div>
</div>
<div id="hfix-and-hcofree-6" class="slide section level2">
<h2>HFix and HCofree</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> HFix[F[_[_], _], I](unfix: F[HFix[F, ?], I])

<span class="kw">case</span> <span class="kw">class</span> HCofree[A, F[_[_], _], I](a: A, uncf: F[HCofree[A, F, ?], I])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> HEnvT[A, F[_[_], _], G[_], I](a: A, fg: F[G, I])</code></pre></div>
</div>
<div id="hfix-and-hcofree-7" class="slide section level2">
<h2>HFix and HCofree</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> HFix[F[_[_], _], I](unfix: F[HFix[F, ?], I])

<span class="co">//case class HCofree[A, F[_[_], _], I](a: A, uncf: F[HCofree[A, F, ?], I])</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> HEnvT[A, F[_[_], _], G[_], I](a: A, fg: F[G, I])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> HCofree[A, F[_[_], _], I] = HFix[HEnvT[A, F, ?[_], ?], I]</code></pre></div>
</div>
<div id="working-with-fixpoint-trees" class="slide section level2">
<h2>Working with fixpoint trees</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> HAlgebra[F[_[_], _], G[_]] = F[G, ?] ~&gt; G</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> cata[F[_[_], _]: HFunctor, G[_]](alg: HAlgebra[F, G]): (HFix[F, ?] ~&gt; G) = 
  <span class="kw">new</span> (HFix[F, ?] ~&gt; G) { self =&gt; 
    <span class="kw">def</span> apply[I](f: HFix[F, I]): G[I] = {
      alg.<span class="fu">apply</span>[I](f.<span class="fu">unfix</span>.<span class="fu">hfmap</span>[G](self))
    }
  }</code></pre></div>
</div>
<div id="working-with-fixpoint-trees-1" class="slide section level2">
<h2>Working with fixpoint trees</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> HAlgebra[F[_[_], _], G[_]] = F[G, ?] ~&gt; G</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> cata[F[_[_], _]: HFunctor, G[_]](alg: HAlgebra[F, G]): (HFix[F, ?] ~&gt; G) = 
  <span class="kw">new</span> (HFix[F, ?] ~&gt; G) { self =&gt; 
    <span class="kw">def</span> apply[I](f: HFix[F, I]): G[I] = {
      alg.<span class="fu">apply</span>[I](f.<span class="fu">unfix</span>.<span class="fu">hfmap</span>[G](self))
    }
  }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> HEnvT[A, F[_[_], _], G[_], I](a: A, fg: F[G, I])

<span class="kw">def</span> forgetAlg[A, F[_[_], _]] = <span class="kw">new</span> HAlgebra[HEnvT[A, F, ?[_], ?], HFix[F, ?]] {
  <span class="kw">def</span> apply[I](env: HEnvT[A, F, HFix[F, ?], I]) = <span class="fu">Hfix</span>(env.<span class="fu">fa</span>)
}</code></pre></div>
</div>
<div id="working-with-fixpoint-trees-2" class="slide section level2">
<h2>Working with fixpoint trees</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">type</span> HAlgebra[F[_[_], _], G[_]] = F[G, ?] ~&gt; G</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> cata[F[_[_], _]: HFunctor, G[_]](alg: HAlgebra[F, G]): (HFix[F, ?] ~&gt; G) = 
  <span class="kw">new</span> (HFix[F, ?] ~&gt; G) { self =&gt; 
    <span class="kw">def</span> apply[I](f: HFix[F, I]): G[I] = {
      alg.<span class="fu">apply</span>[I](f.<span class="fu">unfix</span>.<span class="fu">hfmap</span>[G](self))
    }
  }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">final</span> <span class="kw">case</span> <span class="kw">class</span> HEnvT[A, F[_[_], _], G[_], I](a: A, fg: F[G, I])

<span class="kw">def</span> forgetAlg[A, F[_[_], _]] = <span class="kw">new</span> HAlgebra[HEnvT[A, F, ?[_], ?], HFix[F, ?]] {
  <span class="kw">def</span> apply[I](env: HEnvT[A, F, HFix[F, ?], I]) = <span class="fu">HFix</span>(env.<span class="fu">fa</span>)
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> forget[F[_[_], _]: HFunctor, A]: (HCofree[A, F, ?] ~&gt; HFix[F, ?]) =
  <span class="fu">cata</span>(forgetAlg)</code></pre></div>
</div>
<div id="drawbacks" class="slide section level2">
<h2>Drawbacks</h2>
<p>The Scala compiler hates me.</p>
<pre><code>[error] /Users/nuttycom/personal/scala_world-2017/sample_code/xenomorph/src/main/scala/xenomorph/Schema.scala:263: type mismatch;
[error]  found   : [$13$]xenomorph.PropSchema[O,[$40$]xenomorph.HCofree[[$0$[_$1], $1$]xenomorph.SchemaF[P,$0$,$1$],A,$40$],$13$] ~&gt; [$14$]xenomorph.PropSchema[N,[$40$]xenomorph.HCofree[[$0$[_$1], $1$]xenomorph.SchemaF[P,$0$,$1$],A,$40$],$14$]
[error]     (which expands to)  scalaz.NaturalTransformation[[$13$]xenomorph.PropSchema[O,[$40$]xenomorph.HCofree[[$0$[_$1], $1$]xenomorph.SchemaF[P,$0$,$1$],A,$40$],$13$],[$14$]xenomorph.PropSchema[N,[$40$]xenomorph.HCofree[[$0$[_$1], $1$]xenomorph.SchemaF[P,$0$,$1$],A,$40$],$14$]]
[error]  required: [$3$]xenomorph.PropSchema[O,[$2$]xenomorph.HCofree[[$0$[_$1], $1$]xenomorph.SchemaF[P,$0$,$1$],A,$2$],$3$] ~&gt; G
[error]     (which expands to)  scalaz.NaturalTransformation[[$3$]xenomorph.PropSchema[O,[$2$]xenomorph.HCofree[[$0$[_$1], $1$]xenomorph.SchemaF[P,$0$,$1$],A,$2$],$3$],G]
[error]       PropSchema.contraNT[O, N, Schema[A, P, ?]](f)</code></pre>
<p>That's the result of leaving off a type ascription, there's actually nothing incorrect about the code.</p>
</div>
<div id="conclusion" class="slide section level2">
<h2>Conclusion</h2>
<p>When we're working at kind <code>*</code>, we're dealing with data.</p>
<p>When we're working at kind <code>* -&gt; *</code> we're dealing with descriptions of data.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">A =&gt; B

F[_] ~&gt; G[_]</code></pre></div>
</div>
<div id="conclusion-1" class="slide section level2">
<h2>Conclusion</h2>
<p>When we're working at kind <code>*</code>, we're dealing with data.</p>
<p>When we're working at kind <code>* -&gt; *</code> we're dealing with <strong>descriptions</strong> of data.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">A =&gt; B

F[_] ~&gt; G[_]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">Either[A, B]

Coproduct[F[_], G[_]]</code></pre></div>
</div>
<div id="conclusion-2" class="slide section level2">
<h2>Conclusion</h2>
<p>When we're working at kind <code>*</code>, we're dealing with data.</p>
<p>When we're working at kind <code>* -&gt; *</code> we're dealing with <strong>descriptions</strong> of data.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">A =&gt; B

F[_] ~&gt; G[_]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">Either[A, B]

Coproduct[F[_], G[_]]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Functor[F[_]] {
  <span class="kw">def</span> fmap[A, B](f: A =&gt; B): F[A] =&gt; F[B]
}

<span class="kw">trait</span> HFunctor[F[_[_], _]] {
  <span class="kw">def</span> hfmap[M[_], N[_]](nt: M ~&gt; N): F[M, ?] ~&gt; F[N, ?]
}</code></pre></div>
</div>
</body>
</html>
